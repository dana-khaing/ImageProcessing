(* gcdAttribute.art - GCD calculator with attribute-actions and native Java actions *)
(* Supports plugin expressions with integer return values *)
//!interpreter attributeAction
!support
!! import java.util.Map; import java.util.HashMap; !!
!! Map<String, Integer> variables = new HashMap<>(); 
   Map<String, AbstractAttributeBlock> procedures = new HashMap<>(); 
   int successCount = 0; 
   int failCount = 0;
   int switchVal;
   boolean CheckContinues= false;
   !!

initAndTest ::=  !!variables.clear(); !!
  statements
  !! System.out.println("Tests completed: " + successCount + " successes, " + failCount + " failures"); !!  // Test summary

statements ::= 
  statement statements
| statement !! System.out.println("Final variable map " + variables); !! 

statement ::= 
  ID ':=' e0 ';' !! variables.put(ID1.v, e01.v); !!     // Assignment
| ID '+=' e0 ';' !! variables.put(ID1.v, variables.get(ID1.v) + e01.v); !! // Increment
| ID '-=' e0 ';' !! variables.put(ID1.v, variables.get(ID1.v) - e01.v); !! // Decrement
| ID '*=' e0 ';' !! variables.put(ID1.v, variables.get(ID1.v) * e01.v); !! // Multiply
| ID '/=' e0 ';' !! variables.put(ID1.v, variables.get(ID1.v) / e01.v); !! // Divide
| ID '%=' e0 ';' !! variables.put(ID1.v, variables.get(ID1.v) % e01.v); !! // Modulus

| 'if' e0 'then' statements!< elseOpt!<                  // If statement 
  !! if (e01.v != 0) {interpret(statements1);} else{ interpret(elseOpt1);} !! 


| 'while' e0!< 'do' statements!< 'fin' ';'                        // While statement 
  !! interpret(e01); 
  while (e01.v != 0) { 
    interpret(statements1); 
    interpret(e01); 
  } !! 

| 'for' ID ':=' e0 ';' e0!< ';'statement!< 'do' statements!< 'fin' ';'     // For loop (range-based)
  !! for (variables.put(ID1.v, e01.v), interpret(e02); e02.v != 0; interpret(statement1)) { interpret(statements1); interpret(statement1); interpret(e02);} !!

| 'switch' '(' e0 ')' '{' cases!< '}' ';' 
 !! switchVal = e01.v; interpret(cases1);  switchVal=0; CheckContinues=false;!!


| 'print' '(' printElements ')' ';' // print statement 

| 'procedure' ID statement!< !! procedures.put(ID1.v, statement1); !!  // procedure

| 'call' ID ';' !! interpret(procedures.get(ID1.v)); !! 

| '{' statement '}'                                   //Compound statement

| 'plugin' '(' STRING_SQ ')' ';' !! plugin(STRING_SQ1.v); !!
| 'plugin' '(' STRING_SQ ',' e0 ')' ';' !! plugin(STRING_SQ1.v, e01.v); !!
| 'plugin' '(' STRING_SQ ',' e0 ',' e0 ')' ';' !! plugin(STRING_SQ1.v, e01.v, e02.v); !!
| 'plugin' '(' STRING_SQ ',' e0 ',' e0 ',' e0 ')' ';' !! plugin(STRING_SQ1.v, e01.v, e02.v, e03.v); !!
|'init' ';'           !! plugin("init"); !!
| 'load' STRING_SQ ';'   !! plugin("load", STRING_SQ1.v); !!
| 'invert' ';'           !! plugin("invert"); !!
| 'brightness' e0 ';' !! plugin("brightness", e01.v); !!
| 'contrast' e0 ';' !! plugin("contrast", e01.v); !!
| 'rotate' e0 ';' !! plugin("rotate", e01.v); !!
| 'grayscale' ';' !! plugin("grayscale"); !!
| 'sobel' ';' !! plugin("sobel"); !!
| 'blur' e0 ';' !! plugin("blur", e01.v); !!
| 'summerVibe' ';' !! plugin("summerVibe"); !!
| 'ASSERT' '(' e0 ',' e0 ')' ';'                      // Assertion statement
  !! if (e01.v == e02.v) { 
       System.out.println("** Successful Test **");
       successCount++; 
     } else { 
        System.out.println("** Failed Test **");
       failCount++; 
     } !!

elseOpt ::= 
'elseif' e0 'then' statements!< elseOpt // 'elseif'
!! if (e01.v != 0) {interpret(statements1);} else{ interpret(elseOpt1);} !!
|'else' statement
| #

cases ::='default' ':' statements!< 'break' ';'    // Default case
!! interpret(statements1);!!
| 'default' ':' statements!<                 // Default case without break
!! interpret(statements1);!!
| 'default' ':' statements!<  'continue'','               // Default case without break
!! interpret(statements1);!!
| 'case' e0 ':' statements!< 'break' ';'  cases!<        // Case statements
!! if (switchVal == e01.v && CheckContinues == false){interpret(statements1);} else if (switchVal == e01.v && CheckContinues == true) {interpret(statements1);CheckContinues=false;} else {interpret(cases1);}!!
| 'case' e0 ':' statements!<   cases!<               // Case statements without break
!! if (switchVal == e01.v) {interpret(statements1);  CheckContinues= true; interpret(cases1);} else {interpret(cases1);}!!
| 'case' e0 ':' statements!< 'continue' ';'   cases!<               // Case statements without break
!! if (switchVal == e01.v) {interpret(statements1);  CheckContinues= true; interpret(cases1);} else {interpret(cases1);}!!
| 'case' e0 ':' statements!< 'break' ';'      // End Case statements with break
!! if (switchVal == e01.v || CheckContinues == true) {interpret(statements1);}!!
| 'case' e0 ':' statements!<               //End Case statements without break
!! if (switchVal == e01.v || CheckContinues == true) {interpret(statements1);}!!
| 'case' e0 ':' statements!< 'continue' ';'              //End Case statements with continue
!! if (switchVal == e01.v || CheckContinues == true) {interpret(statements1);}!!


printElements ::=
  STRING_SQ !! System.out.print(STRING_SQ1.v); !!
  | STRING_SQ !! System.out.print(STRING_SQ1.v); !! ',' printElements
  | e0 !! System.out.print(e01.v); !!
  | e0 !! System.out.print(e01.v); !! ',' printElements


e0 <v:int> ::=
  e1         !! e0.v = e11.v; !!
| e1 '>'  e1 !! e0.v = e11.v >  e12.v ? 1 : 0; !!     // Greater than
| e1 '<'  e1 !! e0.v = e11.v <  e12.v ? 1 : 0; !!     // Less than
| e1 '>=' e1 !! e0.v = e11.v >= e12.v ? 1 : 0; !!     // Greater than or equals
| e1 '<=' e1 !! e0.v = e11.v <= e12.v ? 1 : 0; !!     // Less than or equals
| e1 '==' e1 !! e0.v = e11.v == e12.v ? 1 : 0; !!     // Equal to
| e1 '!=' e1 !! e0.v = e11.v != e12.v ? 1 : 0; !!     // Not equal to
| e0 '&&' e0 !! e0.v = (e01.v != 0) && (e02.v != 0) ? 1 : 0; !!  // Logical AND
| e0 '||' e0 !! e0.v = (e01.v != 0) || (e02.v != 0) ? 1 : 0; !!  // Logical OR
| e0 'and' e0 !! e0.v = (e01.v != 0) && (e02.v != 0) ? 1 : 0; !!  // Logical AND
| e0 'or'  e0 !! e0.v = (e01.v != 0) || (e02.v != 0) ? 1 : 0; !!  // Logical OR
| e0 'xor' e0 !! e0.v = (e01.v != 0) ^ (e02.v != 0) ? 1 : 0; !!  // Logical XOR

e1 <v:int> ::= 
  e2         !! e1.v = e21.v; !!  
| e1 '+' e2 !! e1.v = e11.v + e21.v; !!               // Add
| e1 '-' e2 !! e1.v = e11.v - e21.v; !!               // Subtract 

e2 <v:int> ::=
  e3         !! e2.v = e31.v; !!
| e2 '*' e3 !! e2.v = e21.v * e31.v; !!               // Multiply
| e2 '/' e3 !! e2.v = e21.v / e31.v; !!               // Divide
| e2 '%' e3 !! e2.v = e21.v % e31.v; !!               // Mod

e3 <v:int> ::=
  e4         !! e3.v = e41.v; !!
| '+' e3    !! e3.v = e31.v; !!                       // Positive
| '-' e3    !! e3.v = -e31.v; !!                      // Negate
| '!' e3    !! e3.v = e31.v == 0 ? 1 : 0; !!         // Logical NOT

e4 <v:int> ::=
  e5         !! e4.v = e51.v; !!
| e5 '**' e4 !! e4.v = (int) Math.pow(e51.v, e41.v); !! // Exponentiate

e5 <v:int> ::=
e6           !! e5.v = e61.v; !!
| ID '++'    !! e5.v = variables.get(ID1.v); variables.put(ID1.v, e5.v + 1); !! // Post-increment
| ID '--'    !! e5.v = variables.get(ID1.v); variables.put(ID1.v, e5.v - 1); !! // Post-decrement

e6 <v:int> ::=
  e7         !! e6.v = e71.v; !!
| '++' ID    !! e6.v = variables.get(ID1.v); variables.put(ID1.v, e6.v + 1); !! // Pre-increment  
| '--' ID    !! e6.v = variables.get(ID1.v); variables.put(ID1.v, e6.v - 1); !! // Pre-decrement

e7 <v:int> ::=
  INTEGER    !! e7.v = INTEGER1.v; !!                       // Integer literal
| ID         !! e7.v = variables.getOrDefault(ID1.v, 0); !! // Variable (default 0 if undefined)
| '(' e1 ')' !! e7.v = e11.v; !!                            // Parenthesized expression
| 'sqrt' '(' e0 ')' !! e7.v = (int) Math.sqrt(e01.v); !!            // Square root
| 'sin' '(' e0 ')' !! e7.v = (int) (Math.sin(e01.v) * 1000); !!     // Sine (scaled)
| 'cos' '(' e0 ')' !! e7.v = (int) (Math.cos(e01.v) * 1000); !!     // Cosine (scaled)
| 'abs' '(' e0 ')' !! e7.v = Math.abs(e01.v); !!     // Absolute value
| 'read' '(' ')'   !! System.out.print("Input: "); e7.v = Integer.parseInt(System.console().readLine()); !! // Read input
| 'plugin' '(' STRING_SQ ',' e0 ')' !! e7.v = (int) plugin(STRING_SQ1.v, e01.v); !!                         // Plugin with return value

(* Lexical rules *)
ID <v:String>        ::= &ID !! ID.v = lexeme(); !!  
STRING_SQ <v:String> ::= &STRING_SQ !! STRING_SQ.v = lexemeCore().translateEscapes(); !!
INTEGER <v:int>      ::= &INTEGER !! INTEGER.v = Integer.parseInt(lexeme()); !!
REAL <v:double>      ::= &REAL !! REAL.v = Double.parseDouble(lexeme()); !!

(* Test cases *)
//!try "a := 0; b := 3; while a != b do b := b - 1; fin; ASSERT(a, 0);"
//!try "plugin('init');"

//!try "a := 0; b := ++a; c := a + b; ASSERT(c, 1);"
//!try "a := -3; b := 4; c := a + 2 * 3 >= b / 2 - 4; ASSERT(c, 1);"
//!try "a := 2; for i := 0 ; i < 2; i := i + 1; do a := a + i; fin ; ASSERT(a, 4);"
//!try "procedure dana { print('Welcome To My World\n'); } call dana;"
//!try "a := 1; b := 3; if a == 0 then b := b - 1; else a := b; ASSERT(a, 3);"
//!try "a := 1; b := 3; if a == 0 then b := b - 1; elseif a > 0 then b := b+1; else a := b; ASSERT(b,4);"
(*
!try "a :=1; switch(a) {
  case 0: a := a + 7; break;
  case 1: a := a + 2; continue;
  case 2: a := a + 2; 
  } ; ASSERT(a, 5);"
*)
//!try "a := 2; a += 3; ASSERT(a, 5);"
//!try "a := 2; a -= 3; ASSERT(a, -1);"
//!try "a := 2; a *= 3; ASSERT(a, 6);"
//!try "a := 2; a /= 3; ASSERT(a, 0);"

!try "init; load 'mountain.jpg'; blur 2;"